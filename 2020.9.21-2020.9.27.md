http://124.205.120.153/problem/1738

给定一无向图，对于每个从S到T关键节点$i$，输出用从S到$i$所用时间能走到多少不同的位置(卡在路中间也算)

对于每条边(不包含两点)，在时间轴上将进入到离开这条边的时间段区间+1；则答案就是时间轴上该点的值；点为了避免重复计算单独放进去；用差分实现

正解就是将所有时间离散化



http://zhengruioi.com/contest/696/problem/1491

给定一串01串，每次操作可以将连续的 长度为$k$的颜色相同串颜色反转；求经过若干次操作后a能否变成b

在给定某些操作 求字符串a是否可以转换成b时 当操作可逆时 一种思路是尝试把a,b向另外一个状态(比如最小字典序)转移

本题中注意到k*'0'+'1'可以转移到'1'+k*'0'，所以我们求最大字典序时可以把u个k*'0'扔到后面去；同理把v个k*'1'扔到前面去，记录下a,b的u,v个数，以及卡在中间无法转移的字符串，比较即可



http://zhengruioi.com/problem/1532

有一个等差数列的集合 你只知道集合可能的最大值 某些数属于它和另一些数不属于它 求集合的情况数

暴力的思想就是枚举公差 逐个条件check 正解就是优化公差可能性：公差只能是所有已知的相邻的存在的数的差的约数，这样只需要check内部不存在和两端点即可



https://www.luogu.com.cn/problem/P3527

有$m$个位置，每个位置属于一个种类；在位置上有$k$次操作区间加，求对于每一个种类$i$经过多少次操作后收益和$\geq aim[i]$

考虑如果只有一次询问可以二分答案+树状数组check；多组询问可以考虑整体二分(分治)：将一堆询问按照答案的位置二分 直到答案位置确定，需要保证check $n$组询问的复杂度在$O(n)到O(nlogn)$即可



http://124.205.120.153/problem/1737

给定$k$个$n\times m$，求最少的位置数可以把它们区分开

如果每一对都区分开，就是题目所求的答案了

考虑预处理选择$bin[i]$表示第i个点可以区分(a,b)这两个矩阵，将对编号压入整数；则$dp[status]$表示区分情况为status的情况下最多需要的点数；$dp[statue|bin[i]]=min(dp[statue|bin[i]],dp[statue]+1)$



http://124.205.120.153/problem/1721

给定一树，对于每个点随机选择一条连向儿子的边作为重边；求每个点作为根节点时，所有点到根经过的轻边条数和的期望

先考虑以1为根，如果一条边作为轻边，那么对答案的贡献是他所有儿子的节点个数；$dp[i]$表示i所有向儿子连的边的贡献和，则$dp[i]=\sum\limits_{j=son[i]}siz[j]*(1-\frac{1}{son[i]})=(1-\frac{1}{son[i]})\times (siz[i]-1)$；最终答案就是所有$dp[i]$的和
考虑换根的时候只有两个dp值发生了改变



http://124.205.120.153/problem/1774

给定一无向图，每个点上有一些硬币，一次操作让该点向与它相连的所有点分发一枚硬币，求初始硬币状态和一操作序列，使按此序操作后硬币状态不变；求一初始硬币状态使得无论如何操作总能继续操作

第一问的操作序列一定是1-n的排列，字典序最小就是1-n了，考虑i点的初始状态，1\~i-1与它相连的点可以给它a个，它需要给1-n中与它相连的点a+b个，所以该点需要至少放置b个硬币，即i+1~n中与它相连的点的个数

第一问中给出的初始状态就是答案，因为如果从中间某点开始操作，前面的也一定可以后来操作，这样转一圈就又回到了初始状态



http://zhengruioi.com/contest/704/problem/1555

给定一数列 可以任意选择一数花费1代价+1或-1 求最小代价使数列中任意两数的GCD为1

由于$a[i]\leq 30$，而且$a[i]$最多变成$2a[i]$，在往上就不如变成1人畜无害，所以$dp[i][statue]$表示前$i$个数 把质数阵用成$statue$样子时最小花费 $dp[i][statue|j]=min(dp[i][statue|j],dp[i][j]+abs(j-a[i]))$



