http://zhengruioi.com/contest/764/problem/1695

给定一二叉树，每个点初始黑或白色，两种操作：一：将简单路径上的点全部翻转；二：将子树内的点全部翻转；且前者不能有点相交，求最少操作次数使得树变为纯色

不能有点相交意味着每个点最多从子树中保留一条路径等待和更上面的点构成简单路径，所以令$dp[i][0/1][0/1]$表示以$i$为根的子树中，第二维记录颜色，第三维$0$表示子树是纯色，$1$表示有一条路径是反色

对于纯色子树，如果要求其颜色与根不一样：

①两棵子树与根颜色相同，最后用操作二

②两棵子树与要求颜色相同，根单独用操作一

③选一棵子树留一条和根颜色相同的路径，另一棵子树与要求颜色相同，用操作一

④两棵子树都留和根颜色相同的路径，用操作一

纯色子树之间用操作二转化

对于留一条路径的情况，如果路径保留颜色与根相同，其余点为其余颜色：

①选一棵子树留一条和根颜色相同的路径，另一棵子树保持其余颜色

②两棵子树均保持其余颜色，根单独作为保留颜色



http://codeforces.com/contest/1447/problem/D

给定两个字符串$a,b$，从中各选一个子串$c,d$，最大化$4\times LCS(c,d)-|c|-|d|$

奇怪的值可以用dp维护，$dp[i][j]$表示以$a[i],b[j]$为结尾的最大值，$dp[i][j]=max(dp[i-1][j]-1,dp[i][j-1]-1,0,[a[i]==b[j]]\times (dp[i-1][j-1]+4-2))$



http://zhengruioi.com/contest/771/problem/1697

一个序列初始只有一个$1$，给定其可能最大值$M$，每次有两种操作，一：在序列末尾插入$1$或$M$；二：选择一个非开头和末尾的位置$i$，插入一个$x$，$a_i<x<a_{i+1}$或$a_i>x>a_{i+1}$

先考虑最终序列的种类数，再计算能完成该序列的方案数

将序列中关键值$1,m$拉出来构成一条链，两个关键值之间的其他点都连在后一个关键值上，只要两个关键值不同，中间就可以插入若干点

能完成该序列的方案数就是树的拓扑序数量，考虑若没有限制是$n!$种，考虑以$i$为根的子树大小为$siz[i]$，则对该$siz[i]$个数来说有限制：拓扑序中$i$必须在其余点之前出现，于是相对于全排列，只有$\frac{1}{siz[i]}$种方案满足条件，考虑所有子树，只有$\frac{n!}{\prod siz[i]}$种满足条件

设$dp[i]$表示用了$i$个元素的方案数，每次考虑插入一个关键值和$j$个点其余值：$dp[i]=dp[i-1]\times \frac{1}{n-(i-1)}+\sum\limits_{j=1}^{i-1} dp[i-j]\times \binom{m-2}{j} \times \frac{1}{n-(i-j)}$



http://zhengruioi.com/contest/454/problem/1018

给定若干十进制下的分数，求一进制$k$使得所有分数在该进制下都是有限位小数

考虑一定存在$m$，使得任意$k$进制下的有限位小数$c\times k^m$为整数，设分数$\frac{a}{b}=c$，两边同乘$k^m$次方后应该都是整数，所以一定有$b|k^m$，由于$m$可以很大，所以只需要要求$k$中含有所有分母的质因子即可(约分后的)



http://140.143.166.224/contest/problem?id=38&pid=2

给定一有边权的树，求至少断多少条边，使得各个部分的直径不超过$k$

菊花图的时候将每条边的权值放入优先队列，每次查看最大的两条边权之和是否$>k$，如果大于则割掉最大的边

这个结论扩展到树里也是成立的，以某个点为根的子树中可以至多留一条长度$\leq k$的路径到其父亲，而父亲在合并若干子树时如果最大的两条边权之和$>k$则割掉最大路径



http://140.143.166.224/contest/problem?id=38&pid=3

定义$f(x,y,z)=\begin{cases}1,z=0\\ \sum\limits_{x1=1}^x \sum\limits_{y1=1}^y(x-x1+1)(y-y1+1)f(x1y,1,z-1),z\geq 1\end{cases}$，求$\sum\limits_{n=1}^N\sum\limits_{m=1}^Mf(n,m,K)$

这个转移式子相当于在$n\times m$的矩形内，选$k$次子矩形（每次在上一次选出的矩形内选）的方案数，每次枚举内部的子子矩形边长为$x1,y1$进行转移

由于边可以压线，所以枚举总共选了$x$行，相当于将$2k$个不考虑顺序的子矩形的边的求放入$x$个盒子；$y$同理；所以有$f(n,m,k)=\sum\limits_{x=1}^n\sum\limits_{y=1}^m \binom{n}{x}\binom{m}{y}\binom{2k-1}{x-1}\binom{2k-1}{y-1}$，单看$\sum\limits_{x=1}^n\binom{n}{x}\binom{2k-1}{x-1}=\sum\limits_{x=1}^n\binom{n}{n-x}\binom{2k-1}{x-1}=\binom{n+2k-1}{n-1}$，于是$ans=\sum\limits_{n=1}^N\sum\limits_{m=1}^M\binom{n+2K-1}{2K}\binom{m+2K-1}{2K}=\binom{N+2K}{2K+1}\binom{M+2K}{2K+1}$

求组合数时先$Lucas$，分块打表$(x\times 1000000)!$，每次找到对应块再向上乘一些就可以较快的得到阶乘



http://140.143.166.224/contest/problem?id=38&pid=1

多次询问前$n$个数中$gcd$为$1$的子集个数

考虑$\sum\limits_{d|n}\mu(d)=\begin{cases} 1,n=1 \\ 0,n\neq 1 \end{cases}$，可以理解为在质因子上的容斥最终$=0$，所以对于所有前$i$个数的子集，将他们乘上$\sum\limits_{x|gcd}\mu(x)$再相加就是答案

具体的有$f(d)=2^{t(d)}-1$表示$d|gcd$的集合的个数，其中$t(d)$表示$d$的倍数的个数

答案就是$ans[i]=\sum\limits_{d=1}^i\mu(d)f(d)$，随着$i$的增加，每次只有因数个$f(d)$发生变化，直接暴力修改即可



http://zhengruioi.com/contest/771/problem/1698

给定$n$个数和$c$，每次可以花费$x^2+c$的让任意一个数增加$x$，多次询问让所有数$\geq k$的最小代价

是个完全背包，但数据范围过大

完全背包在较大范围时可以用贪心选择性价比最高的，本题中性价比最高的优先选择$\sqrt c$附近的值；对于每个数，如果其距离$k\leq c$则可以准确背包出最小代价，否则一定是先跳若干个完整的$\sqrt c$块后再一步跳到$k$，由于最后一步的步幅不同，所以按原数对$\sqrt c$取模的结果分类就可以确定最后一步的步幅与代价；具体可以通过预处理前缀每个剩余西的数字个数，完整块个数快速算出答案



http://codeforces.com/contest/1446/problem/C

给定若干个不同的数，每个数向其余的和它异或值最小的数连无向边，求至少删掉几个数后，成为一棵树

可以观察到原来肯定是森林，最小删除数$=$最大保留数，而且对于每个数肯定会找到和自己拥有最长前缀的数连边，而且对于若干前缀相同而当前位不同的数，要么全$1+$一个$0$，要么全$0+$一个$1$，否则就会分离；这启发我们上Trie树，设$f[i]$表示$i$子树的最大合法保留数，$f[i]=f[ls[i]]+f[rs[i]]+(ls[i]\& rs[i])$



http://zhengruioi.com/contest/723/problem/1572

求一长度为$k$的黑白序列的种类数，有两种限制：一，区间内至少有一个黑色；二，区间内至少有一个白色

将所有时间点离散化，设$f[i],g[i],h[i]$表示在$i$时间点，满足所有限制条件且最后一个时间段纯黑/纯白/黑白相间的情况数，转移时考虑新扩展出一个时间点，如果要求最后一段是纯色，就需要枚举上一个限制位置到上一个时间点之间最后一个纯反色或黑白相间的时间段，把方案数求和，并认为在此之后都是纯色；如果要求最后一段是黑白相间，则无论上一个时间段的颜色如何，当前时间段一定满足所有限制条件，只需要从上一个时间段转移即可



http://codeforces.com/contest/1446/problem/D1

给定一列数，求最长子串的长度，使其中出现次数最多的数的出现次数与次多的出现次数相同

$a[i]\leq 100:$通过观察可以发现一个序列中最多的永远是其满足要求的子串中最多的，然而在这里就卡住了；实际上考虑整个序列中出现最多的数$x$，一定也是答案串中最多的，所以我们只需要枚举另外一个数$y$在某个子串中和$x$的个数一样，**不用管其他数**，于是就是经典$+-1$开桶记录每个前缀和出现的最早的位置



http://zhengruioi.com/contest/746/problem/393

给定一二分图，左侧每个点会向右侧连续的一段点连边，每个点有权值$1$；现请你给每个点一个权值$2$，对于一个点，如果所有与他相连的点的权值$2$都$<$他本身的权值$2$，则不会被选择，否则会；最大化被选择点的权值$1$的平均值

没有被选择点集一定是个独立集$u$，且只要找到一个独立集，一定存在一种权值$2$的分配使且仅使该独立集没有被选择，此时的平均值$=\frac{sum-\sum\limits_{i\in u} a[i]}{n+m-|u|}$

考虑二分平均值$w$并check是否存在$u$满足$\frac{sum-\sum\limits_{i\in u} a[i]}{n+m-|u|}\geq w$，$sum-w(n+m)-\sum\limits_{i\in u}(a[i]-w)\geq 0$，$sum-w(n+m)+\sum\limits_{i\in u}(w-a[i])\geq 0$，忽略那些$w-a[i]<0$的点，即我们要求一可能的独立集的最大权值和

考虑一个左侧的点作为独立集中的一个点，当且仅当不存在右边的被选点在其连边区间内，于是对右侧点设$dp[i]$表示考虑到右侧第$i$个点且选$i$的最大权值，$dp[i]=max_{j=1}^{i-1}\{dp[j]+\sum\limits_{k}^{j<l[k]~\&~r[k]<i}a[k]\}$，考虑$i$单增的时候，将所有的连边区间按右端点排序，后一个条件恒满足，也就是说我们可以在$i$处将$a[k]$的值直接加在$dp[j]$上（$r[k]==i$，$j<l[k]$），则此后的$dp[i]=max_{j=1}^{i-1}dp[j]$，维护dp数组的区间加法和区间求最大值，用线段树即可