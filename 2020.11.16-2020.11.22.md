http://140.143.166.224/contest/problem?id=33&pid=1

给定一数列和$x$，求有多少个区间的最大值与最小值之和$=x$
$$
max\{a_i\}+min\{a_i\}=x\\
max\{a_i\}=x-min\{a_i\}=x+max\{-a_i\}=max\{x-a_i\}
$$
即找到$max\{a_i\}$与$max\{x-a_i\}$相等的区间；枚举右端点，将当前位置对应的两种值标成不同颜色放到同一个单调栈里面维护到某个左端点的最大值，如果当前值比原栈顶大，说明原来那一套max值一定不能再贡献，直接踢掉，如果值相同，弹掉那些和当前加入值颜色也一样的点，因为可能和颜色不一样的点组成合法区间；单调栈中每两个相邻的且值相同颜色不同的点都能和右端点构成合法区间，只要左端点位于较早点的左边且max值不变，所以可以在每次加入/删除栈顶的时候更新整个栈对新进点的贡献



http://140.143.166.224/contest/problem?id=33&pid=0

给定一棵树，求根到每个点的有向链上后缀最大值的个数

考虑链上的情况，实际上只需要扫右端点的时候维护一个单调栈，单调栈中还剩下的元素个数就是后缀最大值的个数；换到树上我们还需要回溯，考虑每次加入一个点只更改他应该在的位置的数，把新的栈顶传到下一个数，最后再把该位置的数改回来就可以完整地把栈改回来了



http://140.143.166.224/contest/problem?id=33&pid=2

给定数列上的若干询问区间，求在不同的块长下，走完所有询问所需要的步数

如果没有分块，那么步数就是询问长度之和，每跳一块就能节省$B-1$步，所以对于每个块长枚举每个块，求完整跨过该块的询问次数即可，不考虑被块包含的询问，则次数等于位于块左端点左侧的询问左端点数$-$位于块右端点左侧的询问右端点数，这样剩下的一定是左边开始一直到右边结束的，用树状数组维护即可；排除被包含的情况，只需要把询问的长度排序，倒序枚举块长，每次只加进来比块长长的询问即可