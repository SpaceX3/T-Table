http://140.143.166.224/contest/problem?id=33&pid=1

给定一数列和$x$，求有多少个区间的最大值与最小值之和$=x$
$$
max\{a_i\}+min\{a_i\}=x\\
max\{a_i\}=x-min\{a_i\}=x+max\{-a_i\}=max\{x-a_i\}
$$
即找到$max\{a_i\}$与$max\{x-a_i\}$相等的区间；枚举右端点，将当前位置对应的两种值标成不同颜色放到同一个单调栈里面维护到某个左端点的最大值，如果当前值比原栈顶大，说明原来那一套max值一定不能再贡献，直接踢掉，如果值相同，弹掉那些和当前加入值颜色也一样的点，因为可能和颜色不一样的点组成合法区间；单调栈中每两个相邻的且值相同颜色不同的点都能和右端点构成合法区间，只要左端点位于较早点的左边且max值不变，所以可以在每次加入/删除栈顶的时候更新整个栈对新进点的贡献



http://140.143.166.224/contest/problem?id=33&pid=0

给定一棵树，求根到每个点的有向链上后缀最大值的个数

考虑链上的情况，实际上只需要扫右端点的时候维护一个单调栈，单调栈中还剩下的元素个数就是后缀最大值的个数；换到树上我们还需要回溯，考虑每次加入一个点只更改他应该在的位置的数，把新的栈顶传到下一个数，最后再把该位置的数改回来就可以完整地把栈改回来了



http://140.143.166.224/contest/problem?id=33&pid=2

给定数列上的若干询问区间，求在不同的块长下，走完所有询问所需要的步数

如果没有分块，那么步数就是询问长度之和，每跳一块就能节省$B-1$步，所以对于每个块长枚举每个块，求完整跨过该块的询问次数即可，不考虑被块包含的询问，则次数等于位于块左端点左侧的询问左端点数$-$位于块右端点左侧的询问右端点数，这样剩下的一定是左边开始一直到右边结束的，用树状数组维护即可；排除被包含的情况，只需要把询问的长度排序，倒序枚举块长，每次只加进来比块长长的询问即可



http://zhengruioi.com/contest/719/problem/1612

给定一字符串$s$，求最多可以选出多少子串使得他们彼此不是后缀

以$i$为最后一个点最多只能贡献1，所以我们只要看它能不能贡献，考虑如果$j<i$且以两者为终点无论怎么选都会冲突，一定有$s[1,j]$是$s[1,i]$的后缀，而且为了后面考虑我们舍弃$j$保留$i$；否则一定存在一种起点的选法使两串不冲突



http://zhengruioi.com/contest/716/problem/1593

给定两个字符串$s,t$，取$s$的一个前缀接上$t$的一个后缀构成新字符串(可以为空串)，求有多少种不同的新字符串

假设已经选定$s[1,i]$作为前缀，那么$t[j,n]$以前不能有$s[1,i]$的后缀，而只要限定$t[j-1]!=s[i]$就一定满足条件，否则这一组贡献一定被计算过



https://www.luogu.com.cn/problem/P7077

给定一序列和三类函数：单点加，整体乘，调用其他函数；每类函数有若干种，并给定函数调用序列，求原序列经过操作后的每个数

先不考虑函数三，如果对某个数进行$*x,+y,*z$，除了$*x*z$之外，加法的权值变成了$+y*z$，所以操作序列中每个加法都有个额外系数且$=$操作的后缀积

考虑加入函数三，操作序列是个DAG，一个函数三有顺序地指向了其他的一些函数，函数三可能会作为一个整体被指向，这时候就要贡献出它内部所有的乘积，这可以通过dfs一遍求出；而对于某个函数三内部所指向的函数，除了将当前函数本身所接受到的额外系数向下传，还需要倒序遍历这些指向的函数，即可知道函数内的后缀积以贡献给当前所指向的函数，为了保证复杂度，一个函数要收齐所有函数三的贡献再向下继续贡献，所以按拓扑序转移



https://www.luogu.com.cn/problem/solution/P7078



情况一：两条蛇，一定吃

情况二：如果当前蛇吃掉最弱蛇之后没有变成最弱的，那么它一定会选择吃，因为后面的最强的没有这一轮强，最弱的没有这一轮弱，所以后面吃完之后一定更弱

情况三：如果变成最弱的，就先假设吃，那么就递归的看下一组最强最弱是否会选择吃，最终一定会变成前两种情况而确定下来，这之后吃与不吃组一定是交替出现的，



http://zhengruioi.com/contest/766/problem/394

给定一长度为$n$的01字符串和倍数$k$，求最长子串满足其中$'0'$的个数是$'1'$的个数的$k$倍

考虑如果$k=1$的时候，我们记子串的“特征值”为$'0'$的个数$-'1'$的个数，这样算前缀特征值，而只要两个位置的特征值之差为0即满足条件；$k!=1$时记特征值为$'0'$的个数$-k\times '1'$的个数，这样我们只需要求出每个值的最前/最后出现位置做差即可



http://zhengruioi.com/contest/766/problem/395

给定两个长度为$n$的排列$A,B$，每次操作删除$A$或$B$的第一项，如果二者的第一项不相同，则该次操作可以删掉$A$和$B$的第一项

如果第一项不同肯定选择同时删掉，否则考虑删$A$或删$B$，并从下一次卡住的地方转移；离散化$A$，$dp[i]$表示第一个元素值为$a_i$时被卡住以后最小的操作次数；考虑相邻两次卡关之间ab数组的相对位置差sta是不会变的，所以记录下后面距离最近的距离差为sta的卡关位置即为转移位置$dp[i]=min(删A,删B)=min(dp[last[sta+1]]+last[sta+1]-i,dp[last[sta-1]]+last[sta-1]-i+1)$