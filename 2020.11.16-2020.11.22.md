http://140.143.166.224/contest/problem?id=33&pid=1

给定一数列和$x$，求有多少个区间的最大值与最小值之和$=x$
$$
max\{a_i\}+min\{a_i\}=x\\
max\{a_i\}=x-min\{a_i\}=x+max\{-a_i\}=max\{x-a_i\}
$$
即找到$max\{a_i\}$与$max\{x-a_i\}$相等的区间；枚举右端点，将当前位置对应的两种值标成不同颜色放到同一个单调栈里面维护到某个左端点的最大值，如果当前值比原栈顶大，说明原来那一套max值一定不能再贡献，直接踢掉，如果值相同，弹掉那些和当前加入值颜色也一样的点，因为可能和颜色不一样的点组成合法区间；单调栈中每两个相邻的且值相同颜色不同的点都能和右端点构成合法区间，只要左端点位于较早点的左边且max值不变，所以可以在每次加入/删除栈顶的时候更新整个栈对新进点的贡献



http://140.143.166.224/contest/problem?id=33&pid=0

给定一棵树，求根到每个点的有向链上后缀最大值的个数

考虑链上的情况，实际上只需要扫右端点的时候维护一个单调栈，单调栈中还剩下的元素个数就是后缀最大值的个数；换到树上我们还需要回溯，考虑每次加入一个点只更改他应该在的位置的数，把新的栈顶传到下一个数，最后再把该位置的数改回来就可以完整地把栈改回来了



http://140.143.166.224/contest/problem?id=33&pid=2

给定数列上的若干询问区间，求在不同的块长下，走完所有询问所需要的步数

如果没有分块，那么步数就是询问长度之和，每跳一块就能节省$B-1$步，所以对于每个块长枚举每个块，求完整跨过该块的询问次数即可，不考虑被块包含的询问，则次数等于位于块左端点左侧的询问左端点数$-$位于块右端点左侧的询问右端点数，这样剩下的一定是左边开始一直到右边结束的，用树状数组维护即可；排除被包含的情况，只需要把询问的长度排序，倒序枚举块长，每次只加进来比块长长的询问即可



http://zhengruioi.com/contest/719/problem/1612

给定一字符串$s$，求最多可以选出多少子串使得他们彼此不是后缀

以$i$为最后一个点最多只能贡献1，所以我们只要看它能不能贡献，考虑如果$j<i$且以两者为终点无论怎么选都会冲突，一定有$s[1,j]$是$s[1,i]$的后缀，而且为了后面考虑我们舍弃$j$保留$i$；否则一定存在一种起点的选法使两串不冲突



http://zhengruioi.com/contest/716/problem/1593

给定两个字符串$s,t$，取$s$的一个前缀接上$t$的一个后缀构成新字符串(可以为空串)，求有多少种不同的新字符串

假设已经选定$s[1,i]$作为前缀，那么$t[j,n]$以前不能有$s[1,i]$的后缀，而只要限定$t[j-1]!=s[i]$就一定满足条件，否则这一组贡献一定被计算过



https://www.luogu.com.cn/problem/P7077

给定一序列和三类函数：单点加，整体乘，调用其他函数；每类函数有若干种，并给定函数调用序列，求原序列经过操作后的每个数

先不考虑函数三，如果对某个数进行$*x,+y,*z$，除了$*x*z$之外，加法的权值变成了$+y*z$，所以操作序列中每个加法都有个额外系数且$=$操作的后缀积

考虑加入函数三，操作序列是个DAG，一个函数三有顺序地指向了其他的一些函数，函数三可能会作为一个整体被指向，这时候就要贡献出它内部所有的乘积，这可以通过dfs一遍求出；而对于某个函数三内部所指向的函数，除了将当前函数本身所接受到的额外系数向下传，还需要倒序遍历这些指向的函数，即可知道函数内的后缀积以贡献给当前所指向的函数，为了保证复杂度，一个函数要收齐所有函数三的贡献再向下继续贡献，所以按拓扑序转移



https://www.luogu.com.cn/problem/solution/P7078

给定若干蛇，一条蛇可以吃掉另一条当且仅当其体力值更大，或体力值相等且编号更大，吃掉之后体力值变为二者之差，每条蛇都会在自己不被吃掉的情况下尽可能吃更多的蛇，求最终存活的蛇的数量

情况一：两条蛇，一定吃

情况二：如果当前蛇吃掉最弱蛇之后没有变成最弱的，那么它一定会选择吃，因为后面的最强的没有这一轮强，最弱的没有这一轮弱，所以后面吃完之后一定更弱

情况三：如果变成最弱的，就先假设吃，那么就递归的看下一组最强最弱是否会选择吃，最终一定会变成前两种情况而确定下来，这之后吃与不吃组一定是交替出现的，根据奇偶性可以判断当前这组是否反悔，如果反悔游戏结束，否则游戏在下一轮结束

根据情况二的分析，吃剩下的也可以保证单调，所以无需$set$等高级数据结构，直接开两个队列记录原来的和吃剩下的



http://zhengruioi.com/contest/766/problem/394

给定一长度为$n$的01字符串和倍数$k$，求最长子串满足其中$'0'$的个数是$'1'$的个数的$k$倍

考虑如果$k=1$的时候，我们记子串的“特征值”为$'0'$的个数$-'1'$的个数，这样算前缀特征值，而只要两个位置的特征值之差为0即满足条件；$k!=1$时记特征值为$'0'$的个数$-k\times '1'$的个数，这样我们只需要求出每个值的最前/最后出现位置做差即可



http://zhengruioi.com/contest/766/problem/395

给定两个长度为$n$的排列$A,B$，每次操作删除$A$或$B$的第一项，如果二者的第一项不相同，则该次操作可以删掉$A$和$B$的第一项

如果第一项不同肯定选择同时删掉，否则考虑删$A$或删$B$，并从下一次卡住的地方转移；离散化$A$，$dp[i]$表示第一个元素值为$a_i$时被卡住以后最小的操作次数；考虑相邻两次卡关之间ab数组的相对位置差sta是不会变的，所以记录下后面距离最近的距离差为sta的卡关位置即为转移位置$dp[i]=min(删A,删B)=min(dp[last[sta+1]]+last[sta+1]-i,dp[last[sta-1]]+last[sta-1]-i+1)$



https://www.luogu.com.cn/problem/P5659

给定一带点权的树，每次删边的两个点的点权交换，求删完边之后按点权输出点编号的字典序最小的情况

考虑菊花图的情况，所有与中心相连的边从删除顺序构成一条链，如果是一棵树，某些点权的运输会被偷袭，在这个过程中中心的数的向外/向内移动构成删除链的第一个/最后一个点，这个可以维护删除链上每条边的前继/后继，不可以为了新的条件而打断原来的链；为了满足字典序最小，从小到大给点权找没用过的点作为终点，这个可以用并查集维护，除了最后一个点，其余点都一定要在并查集之外找相应边删对应最小的终点，否则删除链就断了，再去删除那些没有被删除的边时会打乱当前的结果

而正解就是一堆菊花图连起来的情况，从小到大对于每个点权遍历所有点，找到点权最小可以到达的点，并且路径上的点都满足上述菊花图



https://nanti.jisuanke.com/t/T3252

给定一树，并标记若干$(u,v)$之间的简单路径，多次询问$(x,y)$之间的简单路径完整经过了多少标记的路径

可以发现一定是询问两端点同时满足某条件，一选定路径才能被覆盖，于是可以转化为对二维平面上点对$(x,y)$所在位置的限制：

讨论选定路径，不放设$dfsn[u]<dfsn[v],dfsn[x]<dfsn[y]$：

如果$dfsn[u]+siz[u]<=dfsn[v]$，即二者不构成子树包含关系，则对于$dfsn[x]\in [dfsn[u],dfsn[u]+siz[u])~\&~dfsn[y]\in[dfsn[v],dfsn[v]+siz[v])$的点对都会贡献$1$；

否则设$u,v$链上$u$的儿子为$d$，对于$dfsn[x]\in[1,dfsn[d])~\&~dfsn[y]\in[dfsn[v],dfsn[v]+siz[v])\cup dfsn[x]\in[dfsn[v],dfsn[v]+siz[v])~\&~ dfsn[y]\in[dfsn[d]+siz[d],n]$的点对都会贡献$1$

接下来的问题就转化为二维区间加和单点求和，可以做二维差分，答案就是其左下角的差分值之和，将询问和修改都按$x$排序，这样顺着扫过来的时候用一个一维树状数组就可以维护$y$坐标上的前缀和，于是树状数组上求前缀和就是答案



https://nanti.jisuanke.com/t/48943

给定一带边权的无向图，求点$1$所在的最小环

暴力做法是枚举和$1$连的每个点作为起点跑不经过点$1$的最短路，再寻找另一个和$1$相连的点作为终点，找找最小环

对于这种$n^2$的枚举，如果我们可以快速算出集合与集合之间的关系，在这里就是多源最短路，就可以使用二进制分组：枚举每一位二进制，将这一位编号为1的点作为源点，多源最短路后找这一位为0的点作为终点，由于任何两不同点一定有某一位的二进制不一样，所以每一个点对都会被计算到



http://zhengruioi.com/contest/725/problem/1632

给定一字符串$s$，将其分为五部分$A+B+C+D+E=S$，可能有空串，并要求$A+C+E$为回文串，求$|A|+|C|+|E|$的最大值

首先可以将首位相同的的字母逐个删去，这样问题就变成了$A+B+C+D$中最大化回文串$A+C$或$B+C+D+E$中最大化回文串$C+E$，第二个问题反过来和第一个等价，这里只讨论第一个

假设$A+C$的中心点在$A$中，枚举这个中心点$i$，通过manacher求出其回文半径为$t$，左边界为$l=i-t$，右边界为$r=i+t$，问题变成了$r$右边是否存在后缀是$s[l-1,1]$，考虑如果问的是后缀是$[1,l-1]$那就直接拿KMP绝杀，这里我们可以把文本串倒过来，用$s^*$作为文本串和$s$做匹配，其中$s^*$是$s$的倒序，记$f[i]$为$s^*[i]$的匹配数，$g[i]$为$s^*[i]$的前缀最大匹配数，则$[g[n-r]>l-1]$即为所求

假设$A+C$的中心点在$C$中，则问题变成了$k-r$使得$s[k,r]=s[1,k-r+1]$，发现这个东西就是上述$f[r]$

实际做的时候要倒过来，先预处理manacher，KMP，再枚举中心点，同时讨论奇偶性



http://zhengruioi.com/contest/765/problem/1690

给定数列$a[1,n]$和$k,f$，求是否存在数列$b$，$\forall i\in[1,n],b[i]\in[a[i]-k,a[i]]$且删除$f$个数后的公约数为$g$，输出所有存在情况下的$g$

枚举$g$，实际上就是求不满足$a[i]>g\& a[i]\%g\leq k$的$a[i]$的个数是否$\leq f$，把$a[i]$放桶里并做前缀和即可快速知道位于$[u\times g,u\times g+k]$的数的数量，枚举$u$，复杂度是$\sum\limits_{g=1}^{amax}\frac{amax}{g}=amax\times ln(amax)$



http://zhengruioi.com/contest/757/problem/1684

定义两字符串是相似的，当且仅当它们的最长公共子序列的长度$\geq n-2$；求在字符集大小为$R$的情况下，有序对$(A,B)$的个数，其中$|A|=|B|=n$，且$A,B$是相似的

LCS的转移是$dp[i][j]=max\{dp[i-1][j],dp[i][j-1],[a[i]==b[j]]\times (dp[i-1][j-1]+1)\}$，既然要求LCS的长度$\geq n-2$，说明每次最多从$i-2,j-2$的地方转移过来

考虑每次加入一个字符，从第$i$位转移到第$i+1$位时需要的状态有：$dp[i-2][i],dp[i-1][i],dp[i][i],dp[i][i-1],dp[i][i-2],A[i-1],A[i],B[i-1],B[i]$；考虑这$9$个数的本质，其中dp值变成$i-dp[*][*]\leq 2$，字符只需要用$1,2,3,4$记录相等关系

dfs一下，每次枚举$A[i+1],B[i+1]$与$A[i-1],A[i],B[i-1],B[i]$之间的相等关系，便可以找到所有的状态及他们之间的转移$dp[i+1][S']=dp[i][S]\times A[S'][S]$，发现可能的状态只有$123$种

设初始矩阵$F[i][1]$表示初始状态为$i$的方案数，单位矩阵$A[i][j]$表示一步从状态$j$转移到状态$i$的方案数，这样每多一个字符$F=A\times F$，矩阵快速幂一下即可



https://codeforces.com/contest/734/problem/E

给定一棵树，每个节点初始黑色或白色，每次可以将一个相同颜色连通块内的点颜色翻转，求最小操作次数使得整棵树变成一种颜色

既然每次都对一个连通块操作，那我们就把颜色相同连通块先缩点，缩完点后的树是黑白相间的，则最小操作次数就是从直径的中心出发做$\frac{len}{2}$次



http://zhengruioi.com/contest/736/problem/1657

$n$个物品，每个物品物品有重量和价值，$m$个背包，一个背包只能放一个物品，选出一些物品使得他们的重量和价值都是单调不降的，并且都能放到背包中，求最多能选出多少物品

要想都放进去，肯定放入后若干背包，所以二者均按重量排序；要想价值单调不降，设$dp[i]$表示最后一次选的物品的价值为$i$时的最大物品数量，由于我们不清楚第一个物品放哪个背包，但重量最大的物品一定放最后一个背包，所以要倒着做，考虑如果当前位$u$可以由后方物品$v$转移而来，即$dp[value[u]]=max(dp[value[u]],dp[value[v]]+1)$，有$value[u]\leq value[v]$，所以把$dp[value[u]]$放到$value[u]$处，每次查询后缀最大值转移，并检查是否能放进去



http://zhengruioi.com/contest/736/problem/1658



一个重要的转化是我们无需在两只蚂蚁相遇的第一个点让某个人等候，因为如果他们中一定有人要等，那么他们到达根的时间一定是紧挨着的，也就是说我们只需要在根节点处处理同一深度下节点的到达情况，



http://zhengruioi.com/problem/1571

对于$n$个点，给定若干形如$x$必须出现在$y$前面的限制条件，求一出现顺序，依次满足$1,2...n$出现的位置尽可能早

看起来是拓扑排序，对于$i$点的出现，一定要等它前面所有点出现完才能出现，然而对于正图我们不好处理前面的次大点使其尽早出现，所以建反图倒着跑拓扑排序，每次选节点编号最大的使其出现在末尾；对于类似的限制不能求正序字典序是由于可能为了眼前小利丢了重点，可以转化成倒序最大字典序是因为越小的点越会不断被向前挤压，满足条件



http://zhengruioi.com/contest/723/problem/1573

给定数列$a,b,c$和数字$P$，当解$\sum\limits_{i=1}^na[i]\times x[i]\leq P$且$\sum\limits_{i=1}^na[i]\times x[i]\geq P$时，最小化$\sum\limits_{i=1}^n c[i]\times x[i]$，其中$x[i]\in\{0,1\}$

由于所有的$a_i\leq b_i$，所以如果有一种方案满足$sum(a)\leq P\leq sum(b)$，那么对于每一个$x_i=1$的位置，一定可以找到一个$a_i\leq u_i\leq b_i$使得$sum(u)=P$，所以设$dp[i][j]$表示考虑到第$i$位，$sum(u)=j$时$sum(c)$的最小值，$dp[i][j]=min(dp[i-1][j],dp[i-1][j-u]+1),u\in[a[i],b[i]]$，遍历$i,j$转移，$j$单调时拿单调队列维护后一个的最小值



http://zhengruioi.com/contest/723/problem/1571

对于两组数$a[1,n],b[1,m]$，求有多少对$i\in[1,n],j\in[1,m]$使得$a[i]$异或$b[j]$在二进制下恰有两位是1

异或起来有两位为1意味着两个数只有两位不相等

$70pts:$对于$a$中的每个数枚举可能是哪两位和它不一样，这样就得到了所有可能和它贡献的$b$的值，放map里，对$b[i]$求和$map[b[i]]$即可

$90pts:$没必要对一个数枚举两位，$a$变一位$b$变一位，且这两位不能相同；如果这两位相同了还被计算上了，那么一定有$a[i]=b[j]$，而且这一对会被算30遍，减去即可，这之后每一对会被算两遍(a改x，b改y；a改y，b改x)，/2即可

$100pts:$手写哈希表



http://zhengruioi.com/contest/770/problem/127

定义排列的价值为$\sum\limits_{i=1}^n[a[i]==min\{a[1-i]\}]$，求所有$[1,n]$的排列价值平方和

考虑每次在已有排列中加入一个最大的数，$dp[i][j]$表示用$i$个数凑出价值为$j$的排列方案数：

$dp[i][j]=dp[i-1][j-1]+(i-1)\times dp[i-1][j]$，然而没有必要维护出整个dp数组
$$
ans[i]=\sum\limits_{j=1}^ij^2\times dp[i][j]\\=
\sum\limits_{j=1}^i ((j-1)^2+2j+1)\times (dp[i-1][j-1]+(i-1)dp[i-1][j])\\
=ans[i-1]+2b[i-1]+c[i-1]+(i-1)ans[i-1]\\
=i\times ans[i-1]+2b[i-1]+c[i-1]\\
\\
\\
b[i]=\sum\limits_{j=1}^i j\times dp[i][j]\\
=\sum\limits_{j=1}^i (j-1+1)\times (dp[i-1][j-1]+(i-1)\times dp[i-1][j])\\
=b[i-1]+\sum\limits_{j=1}^jdp[i-1][j-1]+(i-1)\times b[i-1]\\
=i\times b[i-1]+c[i-1]\\
\\
\\
c[i]=\sum\limits_{j=1}^idp[i][j]\\
=\sum\limits_{j=1}^i(dp[i-1][j-1]+(i-1)dp[i-1][j])\\
=c[i-1]+(i-1)\times c[i-1]\\
=i\times c[i-1]
$$