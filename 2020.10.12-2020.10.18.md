http://codeforces.com/contest/416/problem/E

给定一有边权的无向图 求出所有点对间最短路所经过的路径条数 多条最短路经过同一条边不会重复计数

如果一条一条路算的话非常不好去重，不妨一个一个点算

对于点对$(i,j)$枚举位于其最短路上的点$k$，统计以$k$为端点，且位于$(i,k)$最短路径上的边的个数$cnt[i][k]$，则$ans[i][j]=\sum\limits_kcnt[i][k]$，只要$cnt[i][k]$没有重复，最终的$dp[i][j]$也不会重复统计

先跑一遍Floyd以方便检查$k$，预处理$cnt[i][k]$只需要枚举$i,k$并检查以$k$为以端点的边的另一端点是否在$(i,k)$的最短路上

复杂度$O(n^3)$

https://codeforces.com/contest/1009/submit

给定一有根无边权树 定义$f[i][j]$表示x的子树中距离为y的点的个数 对每个x求一最小的y使$f[x][y]$最大

无修改的子树问题 可以直接用重链剖分做树上启发式合并 先递归求解轻儿子子树中的点的答案 并把状态数组清零 最后算重儿子子树中的点的答案 状态数组可以带回父节点

令$f'[x][y]$表示x子树中深度为y的点的个数

考虑用长链剖分一条一条链做 在链顶记录$f'[x][y]$ 考虑维护这个信息 实际上链上根本不用转移 链与链之间转移直接暴力枚举长度合并

由于每条连只向链顶父亲所在链合并一次 这一次的复杂度是链长 且总链长=n 所以总时间复杂度为$O(n)$ 同样链顶记录的信息数也只有链长个 所以空间复杂度也是$O(n)$的