http://codeforces.com/contest/416/problem/E

给定一有边权的无向图 求出所有点对间最短路所经过的路径条数 多条最短路经过同一条边不会重复计数

如果一条一条路算的话非常不好去重，不妨一个一个点算

对于点对$(i,j)$枚举位于其最短路上的点$k$，统计以$k$为端点，且位于$(i,k)$最短路径上的边的个数$cnt[i][k]$，则$ans[i][j]=\sum\limits_kcnt[i][k]$，只要$cnt[i][k]$没有重复，最终的$dp[i][j]$也不会重复统计

先跑一遍Floyd以方便检查$k$，预处理$cnt[i][k]$只需要枚举$i,k$并检查以$k$为以端点的边的另一端点是否在$(i,k)$的最短路上

复杂度$O(n^3)$



https://codeforces.com/contest/1009/problem/F

给定一有根无边权树 定义$f[i][j]$表示x的子树中距离为y的点的个数 对每个x求一最小的y使$f[x][y]$最大

无修改的子树问题 可以直接用重链剖分做树上启发式合并 先递归求解轻儿子子树中的点的答案 并把状态数组清零 最后算重儿子子树中的点的答案 状态数组可以带回父节点

令$f'[x][y]$表示x子树中深度为y的点的个数

考虑用长链剖分一条一条链做 在链顶记录$f'[x][y]$ 考虑维护这个信息 实际上链上根本不用转移 链与链之间转移直接暴力枚举长度合并

由于每条连只向链顶父亲所在链合并一次 这一次合并的复杂度是链长 且总链长$=n$ 所以总时间复杂度为$O(n)$ 同样链顶记录的信息数也只有链长个 所以空间复杂度也是$O(n)$的



https://www.luogu.com.cn/problem/P1600

有$m$个人在树上走简单路径，一秒走一步

对于每个点$x$ 询问在第$w[x]$秒有几个人到达该点

考虑第$i$个人在上行过程中被点$x$看到的条件是$depth[x]+w[x]==depth[start[i]]$且$i$在$x$子树内 $lca$在子树外

在下行过程中被看到的条件是$len(start[i],endd[i])-(depth[i]-depth[x])==w[x] \Leftrightarrow w[x]+-depth[x]==len(start[i],endd[i])-depth[i]$

两个桶进行树上差分，每个点回溯的时候作为$start$在$depth[now]$贡献1，作为$endd$在$len(start,endd)-depth[now]$贡献1，统计答案，并在lca处取消这些贡献

特别的是，如果一个人可以在lca处被看到，那一定是被重复计算了两遍，需要减去一遍



http://124.205.120.153/problem/1781

人每天能稳定获得$a[i]$幸福值，如果选择冒险则不会有初始幸福值，会有$p[i]$概率成功获得$b[i]$幸福值，如果失败则不会获得幸福值，求最终获得至少$k$幸福值的概率

$dp[i][j]$表示前$i$已经获得了$j$幸福值，此后到$n$能获得$\geq k$幸福值的概率 $dp[i][j]=max(dp[i+1][j+a[i]],dp[i+1][j]*(1-p[i])+dp[i+1][j+b[i]]*p[i])$ 并将所有$\geq k$的值都堆在k等到被使用

之所以不把$dp[i][j]$设成前$i$已经获得了$j$幸福值的概率 是因为这样转移不能忽略$\geq k$的dp值



https://www.luogu.com.cn/problem/T147584?contestId=30519

有$n$个全甲，$m$个无甲；攻击一次全甲会使其失去甲，同时所有其他人获得甲；攻击一次无甲会使其死亡；每次等概率攻击，求期望攻击次数

部分分$m=0$时：假设当前有$i$条全甲，杀死任意一条的期望次数是$\sum\limits_{j=0}^\infty \frac{1}{i}(1-\frac{1}{i-1})^j\times (j+2)$其中$j$表示除了第一刀和最后一刀，中间浪费了$j$刀；$=\frac{1}{i}\sum\limits_{j=0}^{\infty}(1-\frac{1}{i-1})^j\times (j+2)=i+1$，这样$dp[i]=dp[i-1]+i+1$且$dp[0]=0$，则$dp[n]=\sum\limits_{i=2}^{n+1}i=\frac{n(n+3)}{2}$

加入一些无甲的只会在最开始产生一些影响，第一次刀了全甲的人之后就无异了，所以只需要枚举一下最开始刀死了$m-i$个无甲的，剩下$i+n$个人的期望次数就是上述部分分；这样的概率是$\prod_{j=1}^{m-i} \frac{m-j+1}{m+n-j+1}$，预处理连乘即可
