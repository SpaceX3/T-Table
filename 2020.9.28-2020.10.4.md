http://zhengruioi.com/problem/1556

给定一1-n的排列 询问其中是否含有等差数列(不连续)

想法是以a[i]为中间值，找前缀和后缀是否存在这么差相等的两个位置；H[j]=1表示数字j出现在在[1,i]，h[j]=0表示数字j出现在[i+1,n]，在位置$i$时设$limit=min(n-a[i],a[i]-1)$表示差的最大值，则$H[a[i]-limit]-H[a[i]]$和$H[a[i]+limit]-H[a[i]]$这两个二进制串对位不相等则存在等差数列
H可以随着i增加动态维护；区间判断相等需要哈希，而维护区间哈希值需要线段树



https://www.luogu.com.cn/problem/P3400

求全1子矩阵的个数
统计以每个点为右下角时 左上角可以取的位置的个数 发现这些位置在矩阵中一定是个凸包 因为列方向靠后的低的限制会限制住之前可能的更高的位置取值 用单调栈维护列的限制即可



http://124.205.120.153/problem/1775

求有多少个子矩阵 其内部包含至少一个边长为i的正方形子矩阵 满足子子矩阵的最大值-最小值>=i
事实上只需要在满足条件的2*2的子子矩阵处统计答案即可，因为更大的满足条件的子子矩阵中必然含有至少一个2*2的满足条件的子子矩阵，否则必然有最大值-最小值<=i-1
统计答案的方法：如果是一个点就很方便了，把格子转化成格线交点，这样不会影响答案数；用所有子矩阵数-全0子矩阵数即为答案



http://124.205.120.153/problem/1722

给定一无向图有点权 保证图中没有任何两点之间有任何长度>10的简单路径 求使每个点被选择或相邻点中有一个被选择时的最小花费

没有任何长度>10的简单路径意味着dfs树的深度<10，考虑某个点可能的情况：0表示没选没覆盖 1表示没选但覆盖 2表示选了；$dp[i][j]$表示深度为i 到根的状态为sta时的最小花费，考虑转移：如果当前决策点不选 那他可以白嫖之前祖先选过的变成状态1 没祖先可以嫖就只能转移到状态0；如果当前决策点选 那可以反馈他的祖先

特别注意的是统计答案的方法：由于$dp[i][(212212...12)_3]$只是表示根到当前点都满足条件了，而没有去管后面的点，所以统计答案的时候要用$dp[i+1][j+3^{dep+1}]$和$dp[i+1][j+2\times 3^{dep+1}]$来更新$dp[i][j]$



http://124.205.120.153/problem/1727

给定n个非负整数，每次操作请你选出其中c[i]个正整数-1，求最多操作次数
二分答案，check的时候将减法按个数差分，这样可以保证前缀和是不增的；考虑如何保证一个数只对每个询问贡献一次：首先如果它贡献了第i位的所有询问那就不能往后贡献了，因为后面必然是会重复的；考虑如果有多余的能向前面的第j贡献，那贡献的询问一定是>当前询问个数的那些询问，这意味着第j位的数对本位的贡献>a[i]，即要保证n个数是不增的

