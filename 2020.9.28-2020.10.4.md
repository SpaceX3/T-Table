http://zhengruioi.com/problem/1556

给定一1-n的排列 询问其中是否含有等差数列(不连续)

想法是以a[i]为中间值，找前缀和后缀是否存在这么差相等的两个位置；H[j]=1表示数字j出现在在[1,i]，h[j]=0表示数字j出现在[i+1,n]，在位置$i$时设$limit=min(n-a[i],a[i]-1)$表示差的最大值，则$H[a[i]-limit]-H[a[i]]$和$H[a[i]+limit]-H[a[i]]$这两个二进制串对位不相等则存在等差数列

H可以随着i增加动态维护；区间判断相等需要哈希，而维护区间哈希值需要线段树



https://www.luogu.com.cn/problem/P3400

求全1子矩阵的个数
统计以每个点为右下角时 左上角可以取的位置的个数 发现这些位置在矩阵中一定是个凸包 因为列方向靠后的低的限制会限制住之前可能的更高的位置取值 用单调栈维护列的限制即可



http://124.205.120.153/problem/1775

求有多少个子矩阵 其内部包含至少一个边长为i的正方形子矩阵 满足子子矩阵的最大值-最小值>=i

事实上只需要在满足条件的2*2的子子矩阵处统计答案即可，因为更大的满足条件的子子矩阵中必然含有至少一个2*2的满足条件的子子矩阵，否则必然有最大值-最小值<=i-1

统计答案的方法：如果是一个点就很方便了，把格子转化成格线交点，这样不会影响答案数；用所有子矩阵数-全0子矩阵数即为答案



http://124.205.120.153/problem/1722

给定一无向图有点权 保证图中没有任何两点之间有任何长度>10的简单路径 求使每个点被选择或相邻点中有一个被选择时的最小花费

没有任何长度>10的简单路径意味着dfs树的深度<10，考虑某个点可能的情况：0表示没选没覆盖 1表示没选但覆盖 2表示选了；$dp[i][j]$表示深度为i 到根的状态为sta时的最小花费，考虑转移：如果当前决策点不选 那他可以白嫖之前祖先选过的变成状态1 没祖先可以嫖就只能转移到状态0；如果当前决策点选 那可以反馈他的祖先

特别注意的是统计答案的方法：由于$dp[i][(212212...12)_3]$只是表示根到当前点都满足条件了，而没有去管后面的点，所以统计答案的时候要用$dp[i+1][j+3^{dep+1}]$和$dp[i+1][j+2\times 3^{dep+1}]$来更新$dp[i][j]$



http://124.205.120.153/problem/1727

给定n个非负整数，每次操作请你选出其中c[i]个正整数-1，求最多操作次数

二分答案，check的时候将减法按个数差分，这样可以保证前缀和是不增的；考虑如何保证一个数只对每个询问贡献一次：首先如果它贡献了第i位的所有询问那就不能往后贡献了，因为后面必然是会重复的；考虑如果有多余的能向前面的第j贡献，那贡献的询问一定是>当前询问个数的那些询问，这意味着第j位的数对本位的贡献>a[i]，即要保证n个数是不增的



http://zhengruioi.com/problem/1549

给定一树 选择一个点会覆盖到根路径上的所有点 每次随机选择一个未被覆盖的点 求期望选择次数

$E([p1]+[p2]+[p3]+...+[pn])=E([p1])+E([p2])+...+E([pn])=P([p1])+P([p2])+...+P([pn])=\frac{1}{siz[p1]}+\frac{1}{siz[p2]}+...+\frac{1}{siz[pn]}$

在$pi$及其子树中能且只能选择一个点 则选择$pi$的概率就是$\frac{1}{siz[pi]}$



http://zhengruioi.com/problem/1566

请给$n$个位置上色 给定一排列 使得在任意时刻 被排列前缀选过的所有位置 构成的任意区间上的至少有一种颜色只出现过一次

暴力方法是枚举当前位置的颜色 区间 然后暴力统计check

实际上我们关心的并不是区间 而是某个颜色出现在距离当前位置左右的最近位置 一种颜色的最近/次近都出现在同一区间里 或 只有这一个颜色在该区间里出现了一次 那该颜色就是不可选的 排除了所有不可选的 当前点就染最小的颜色编号；这样左右各有k个位置需要检查用时$k^2$



https://www.luogu.com.cn/problem/P4079

有一堆齿轮 每次给定两个齿轮的传动比 求传动比是否与之前所述存在矛盾

p表示传动比 具有可传递性 若$a->b=p1;b->c=p2$ 则$a->c=p1*p2$

用并查集维护 $p[i]$表示$i$对其父亲的传动比 压缩路径的时候一路乘上去 并的时候推一下式子只用改$p[f2]$即可



https://www.luogu.com.cn/problem/P5679

给定一数列 求其中是否含有等差子序列(不连续)

枚举中点$i$ 要比较$a[i]-d$和$a[i]+d$ 本来是$O(d)$的 如果用bitset记录$i$前缀/后缀中数$j$是否出现过 倒着与一下 可以加速到$\frac{d}{64}$