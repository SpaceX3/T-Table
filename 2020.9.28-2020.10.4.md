http://zhengruioi.com/problem/1556

给定一1-n的排列 询问其中是否含有等差数列(不连续)

想法是以a[i]为中间值，找前缀和后缀是否存在这么差相等的两个位置；H[j]=1表示数字j出现在在[1,i]，h[j]=0表示数字j出现在[i+1,n]，在位置$i$时设$limit=min(n-a[i],a[i]-1)$表示差的最大值，则$H[a[i]-limit]-H[a[i]]$和$H[a[i]+limit]-H[a[i]]$这两个二进制串对位不相等则存在等差数列

H可以随着i增加动态维护；区间判断相等需要哈希，而维护区间哈希值需要线段树



https://www.luogu.com.cn/problem/P3400

求全1子矩阵的个数
统计以每个点为右下角时 左上角可以取的位置的个数 发现这些位置在矩阵中一定是个凸包 因为列方向靠后的低的限制会限制住之前可能的更高的位置取值 用单调栈维护列的限制即可



http://124.205.120.153/problem/1775

求有多少个子矩阵 其内部包含至少一个边长为i的正方形子矩阵 满足子子矩阵的最大值-最小值>=i

事实上只需要在满足条件的2*2的子子矩阵处统计答案即可，因为更大的满足条件的子子矩阵中必然含有至少一个2*2的满足条件的子子矩阵，否则必然有最大值-最小值<=i-1

统计答案的方法：如果是一个点就很方便了，把格子转化成格线交点，这样不会影响答案数；用所有子矩阵数-全0子矩阵数即为答案



http://124.205.120.153/problem/1722

给定一无向图有点权 保证图中没有任何两点之间有任何长度>10的简单路径 求使每个点被选择或相邻点中有一个被选择时的最小花费

没有任何长度>10的简单路径意味着dfs树的深度<10，考虑某个点可能的情况：0表示没选没覆盖 1表示没选但覆盖 2表示选了；$dp[i][j]$表示深度为i 到根的状态为sta时的最小花费，考虑转移：如果当前决策点不选 那他可以白嫖之前祖先选过的变成状态1 没祖先可以嫖就只能转移到状态0；如果当前决策点选 那可以反馈他的祖先

特别注意的是统计答案的方法：由于$dp[i][(212212...12)_3]$只是表示根到当前点都满足条件了，而没有去管后面的点，所以统计答案的时候要用$dp[i+1][j+3^{dep+1}]$和$dp[i+1][j+2\times 3^{dep+1}]$来更新$dp[i][j]$



http://124.205.120.153/problem/1727

给定n个非负整数，每次操作请你选出其中c[i]个正整数-1，求最多操作次数

二分答案，check的时候将减法按个数差分，这样可以保证前缀和是不增的；考虑如何保证一个数只对每个询问贡献一次：首先如果它贡献了第i位的所有询问那就不能往后贡献了，因为后面必然是会重复的；考虑如果有多余的能向前面的第j贡献，那贡献的询问一定是>当前询问个数的那些询问，这意味着第j位的数对本位的贡献>a[i]，即要保证n个数是不增的



http://zhengruioi.com/problem/1549

给定一树 选择一个点会覆盖到根路径上的所有点 每次随机选择一个未被覆盖的点 求期望选择次数

$E([p1]+[p2]+[p3]+...+[pn])=E([p1])+E([p2])+...+E([pn])=P([p1])+P([p2])+...+P([pn])=\frac{1}{siz[p1]}+\frac{1}{siz[p2]}+...+\frac{1}{siz[pn]}$

在$pi$及其子树中能且只能选择一个点 则选择$pi$的概率就是$\frac{1}{siz[pi]}$



http://zhengruioi.com/problem/1566

请给$n$个位置上色 给定一排列 使得在任意时刻 被排列前缀选过的所有位置 构成的任意区间上的至少有一种颜色只出现过一次

暴力方法是枚举当前位置的颜色 区间 然后暴力统计check

实际上我们关心的并不是区间 而是某个颜色出现在距离当前位置左右的最近位置 一种颜色的最近/次近都出现在同一区间里 或 只有这一个颜色在该区间里出现了一次 那该颜色就是不可选的 排除了所有不可选的 当前点就染最小的颜色编号；这样左右各有k个位置需要检查用时$k^2$



https://www.luogu.com.cn/problem/P4079

有一堆齿轮 每次给定两个齿轮的传动比 求传动比是否与之前所述存在矛盾

p表示传动比 具有可传递性 若$a->b=p1;b->c=p2$ 则$a->c=p1*p2$

用并查集维护 $p[i]$表示$i$对其父亲的传动比 压缩路径的时候一路乘上去 并的时候推一下式子只用改$p[f2]$即可



https://www.luogu.com.cn/problem/P5679

给定一数列 求其中是否含有等差子序列(不连续)

枚举中点$i$ 要比较$a[i]-d$和$a[i]+d$ 本来是$O(d)$的 如果用bitset记录$i$前缀/后缀中数$j$是否出现过 倒着与一下 可以加速到$\frac{d}{64}$



http://codeforces.com/problemset/problem/830/C

求最大的$d$满足$\sum\limits_{i=1}^nd-((a_i-1)\%d+1)\leq k$

$\Leftrightarrow dn-\sum\limits_{i=1}^n((a_i-1)-d\frac{a_i-1}{d}+1)\leq k$

$\Leftrightarrow d(n+\sum\limits_{i=1}^n\frac{a_i-1}{d})\leq k+\sum\limits_{i=1}^na_i$

其中对于每个$a_i-1$，$\frac{a_i-1}{d}$有$\sqrt{(a_i-1)}$种取值，所有$n$个共有$n\sqrt{n}$种取值；对于同一个$d=l$整除分块找到$n$个$a_i-1$最小的$r$，则对于$\forall d\in[l,r]$，所有$\frac{a_i-1}{d}$取值相同 $d$直接跳向$r$或跳到不等号右边的限制



http://codeforces.com/problemset/problem/1419/C

给定一数列和一标准数stan每次操作可以对序列中的每个数加减任意 但加减总和=0 操作前后统计每个数是否到达标准态 求至少多少次操作后每个数都到达过标准态

注意到一个数到达过标准态后在下一次操作中可以无限贡献 于是统计初态时比stan大的差的和 比stan小的差的和 若和均为0 则一次操作即可 否则两次

注意特判初态就有=stan的情况 这样即使差不同 也能无限贡献一次操作就结束



http://codeforces.com/problemset/problem/1419/D2

对于一列数(可重) 请给出一种排列 使得最多的数比两边的严格小 左右端点不算

可能的答案最多$\frac{n}{2}$ 贪心的想让前$\frac{n}{2}$贡献 后面当大的 并且分别升序 交替排列

考虑如果大的不够大 耽误了前面的 那一定也会耽误后面的；如果大的不会耽误前面的 也不保证不耽误后面；所以大小都要升序



http://zhengruioi.com/problem/1550

每个选择有两个参数$c1,c2$ 请选择$\leq \frac{n}{2}+1$个选择 使得选择的每个参数的和都大于所有选择该参数的和的一半

一半是一个强条件

注意到$\Delta \frac{sum+c1}{2}<c1$也就是说如果我们做出了一种选法是参数大于$n-1$和的一半 此时在选第$n$个选择一定也是满足条件的 这样我们只处理奇数个选择的情况 偶数可以任选一个变成奇数

为保证$c1$大于一半 将选择按$c1$排序 选最大的 并且在前面两两一组中任选一个 这样即使每组都选$c1$最小的 错一位看就是每组选大的了

为保证$c2$大于一半 每组选择最大的 这样在$n-1$范围内满足 则在$n$或$n+1$范围内都满足