https://ac.nowcoder.com/acm/contest/7615/D

给定一个排列，求有多少个上升序列$\{a_{p1},a_{p2}...a_{pm}\}$，$s.t.\nexists j<p_1\&a_j<a_{p1}$ 且 $\nexists p_i<j<p_{i+1}\& a_{pi}<a_j<a_{pi+1}$ 且 $\nexists p_m<j\& a_{pm}<a_j$

部分分做法是令$dp[i]$表示以$a_i$为结尾的满足前两个条件的上升序列个数，令$amax[j]$表示$j$到$i$之间$>a_j$的最小的数，则$dp[i]=[a_i==min_{j=1}^i\{a_j\}]+\sum\limits_j^{j<i~\&~a_j<a_i~\&~a_i<limit[j]}dp[j]$，要想满足最后一个条件，只需要倒着扫一遍看$a_i$是不是后缀最大值，复杂度$O(n^2)$

考虑每个数作为结尾时，只关注比它小的数，所以我们从小到大加入这些数，重新定义$dp[i]$表示以数字$i$为结尾的满足前两个条件的上升序列个数，$pos[i]$表示数字$i$所在位置；如果$j<i$且$a_j>amax[j+1,i-1]$，那么$dp[j]$就对$dp[i]$有贡献；问题转化为快速算出一个区间的$a_i,a_{i+1},a_{i+2}...$跨过其右边某一定值$limit$的贡献和

建线段树，记录$lans[rt]$表示以$rt$为根的左子树跨过右子树的最大值能贡献的值

如果右子树最大值$<limit$，即无论如何也不可能贡献，则递归处理左子树；否则左子树一定要跨过右子树最大值才能贡献更右边的，即左子树的贡献就是$lans[rt]$，递归处理右子树的贡献；线段树查询区间$[1,pos[i]]$时先做右区间再做左区间可以维护当前区间要跨过的$limit$值

单次询问区间跨过定值的贡献和复杂度为$O(logn)$，而求$[1,pos[i]]$区间会拆成$logn$个区间，所以计算单个$f[i]$的复杂度是$O(log^2n)$的；$lans[rt]$的维护也是一个区间跨过定值的子问题，单个复杂度$O(logn)$，单次更新$pos[i]$位置$f[i]$的值会有$logn$个区间的$lans$被更改，所以单次更新的复杂度是$O(log^2)$的；总时间复杂度$O(nlog^2 n)$



http://zhengruioi.com/contest/759/problem/1685

给定一$01$串，每次选择一个子序列(不连续)包含$a$个$0$和$b$个$1$，且第一个和最后一个被选择的数之间没有前几次被选择过的数，给出一种选择方案，使得每个数都被选过

前缀+后缀不一定能凑成$a$个$0$和$b$个$1$，因为有可能从中间抽走一个

既然无法从外向里剥皮，那就从里面掏空它；每次删除一段满足条件的子串，后面顺位补齐；这个过程可以用栈模拟，顺次加入栈，长度为$a+b$的区间中$0$的个数是连续变化的，所以一定可以找到满足条件的子串，删除后就是另一个子问题也一定可以找到



http://zhengruioi.com/problem/1686

对于$n$个点的无向图，将floyd求连通性最外层循环从$[1,n]$变成$[1,n-m]$，求有多少个图的$n^2$个连通关系都不变

即将$[n-m+1,n]$设为禁点，不参与转移，剩下的$[1,n-m]$为自由点，随意转移

考虑满足条件的图一定满足：如果一个连通块全部由禁点构成，那么一定是个完全图；如果联通块全部由自由点构成，那么只要联通即可，这样的连通块方案数$g[i]$可以预处理出来；如果禁点和自由点混合，禁点之间是完全图，自由点之间联通，且每个禁点都与至少一个自由点相连

设$dp[i][j]$表示一共有$i$个点，其中$j$个点是禁点的方案数，$g[i]$表示$i$个点组成一个联通块的方案数，$g[i]=2^{\frac{i\times(i-1)}{2}}-\sum\limits_{j=1}^{i-1}\binom{i-1}{j-1}\times g[j]\times 2^{\frac{(i-j)\times (i-j-1)}{2}}$即用总数$-$最后一个连通块大小$\neq i$的情况；枚举最后一个连通块中禁点和自由点的数量：如果没有自由点，方案数$+=$其余点的方案数$\times$在所有禁点/自由点中选择的方案数$\times $每个禁点向至少一个自由点连边的方案数$\times$所有禁点连成完全图的方案数，即$dp[i][j]+=\sum\limits_{u=1}^{j}\sum\limits_{v=1}^{i-j}dp[i-u-v][j-u]\times \binom{j-1}{u-1}\times \binom{i-j}{v}\times (2^v-1)^u\times g[v]$；如果有自由点，则对禁点间的连边不做限制，因为无论如何连都可以通过自由点连通$dp[i][j]+=\sum\limits_{u=1}^{j}\sum\limits_{v=1}^{i-j}dp[i-u-v][j-u]\times \binom{j-1}{u-1}\times \binom{i-j}{v}\times (2^v-1)^u\times g[v]\times 2^{\frac{u\times(u-1)}{2}}$



https://ac.nowcoder.com/acm/contest/7613/C

给定一排列，多次询问$[l,r]$区间内字典序第$k$小的数

区间静态第$k$小模板，套个马甲就不认识了？先预处理出$1-n$每个数在字典序下排第几，这个转成字符串sort一下即可，然后将原来的值替换掉，直接上主席树做区间静态第$k$小，输出再把值转回来；本题数据较水，分块也能过，时间十倍



http://zhengruioi.com/contest/754/problem/1674

给定一字符串，求有多少长度为$6$的子序列满足相等/不相等关系形如$114514$

枚举$5$的位置，我们需要知道前缀$114$的数量和后缀$14$的数量，通过dp

$dp0[i][x]$表示$[1,i]$中$x$的个数，$dp0[i][x]=dp0[i-1][x]+[a[i]==x]$

$dp1[i][x]$表示$[1,i]$中$xx$的个数，$dp1[i][x]=dp1[i-1][x]+[a[i]==x]\times dp0[i-1][x]$

$dp2[i][x][y]$表示$[1,i]$中$xxy$的个数，$dp2[i][x][y]=dp2[i-1][x][y]+[a[i]==y]\times dp1[i-1][x]$

$dp3[i][x][y]$表示$[i,n]$中$xy$的个数，$dp3[i][x][y]=dp3[i+1][x][y]+[a[i]==x]\times(dp0[n][y]-dp0[i][y])$

卡了空间，不能开这么多数组，先把$i==1$时$dp3[x][y]$算出来，这样向后推的时候四个式子都能动态维护省掉第一维



http://zhengruioi.com/contest/754/problem/1675

给定一个只含有$!,\&,|$符号的布尔表达式，其中含有$n$个未知数，给定$2^n$种情况下每个未知数的取值，检查表达式的值是否正确

因为没有括号，可以看做是一堆连$\&$(夹杂了一些$!$) 或起来的式子，每一段连与为真解是一定的，而最终只需要完全满足某一块的解即可；于是把$a[i]$的状态压缩进bool数组$0$表示无关，$1$表示必须为false，$2$表示必须为true，读入完一块后可以算出该快涉及到的变量的取值，其他都是无关变量，最后顺着转移一遍即可得到所有可能的解；将需要验证的情况也转成三进制看是否是可能解



http://zhengruioi.com/contest/759/problem/1687

给定一直方图，每个位置有一高度，求被围起来的部分可以画出的第$ql$到第$qr$小矩形的面积

预处理$[l[i],r[i]]$表示可以以$i$为最低点(若高度相同则序号最小)构成矩阵的区间，这样每个矩形都会不重不漏地被统计到；于是可以$O(n)$算出面积$\leq S$的矩阵个数，每个点的贡献为$Cal(\frac{S}{a[i]})-Cal(\frac{S}{a[i]}-l)-Cal(\frac{S}{a[i]}-r)+Cal(\frac{S}{a[i]}-l-r)$其中$Cal(x)=\sum\limits_{i-1}^xi=\frac{i\times (i-1)}{2}$，这样二分出$ql$所在段的面积大小$start$，我们还需要这样向后推到$qr$

后面就是经典问题，由于每个点的矩阵长度取值是连续的，所以把面积$\geq start$最短可能长度放入小根堆(以面积为关键字)，每次取出头部，再加入长度+1的头部，仿照上面容斥也可以$O(1)$算出每个点某一长度下的矩形数量



https://ac.nowcoder.com/acm/contest/7613/D

在二维坐标中给出若干不相交不相切的圆，求从$x$圆弧上任意点到$y$圆弧上任意点至少需要穿过几个圆

可以想到最终一定是从两端分别走，直到被一个更大的圆同时包含；如果一个圆弧套在$x$外面，只要它没有超过更大的圆则一定要穿，否则一定不穿；实际上抽象一下就是在树上跳LCA的过程，于是建树，儿子关系是被套关系，这样答案就是LCA的距离$-1/-2$了；问题转化为快速求圆之间的包含关系(直接)，由于圆之间是不相交的，也就是说在下一个圆进入/离开之前包含关系不变，所以维护每个圆的上弧和下弧所在的$y$坐标，如果当前插入的圆向上的第一个圆是上弧，则是被包含的关系，否则是兄弟关系，这样就可以建出整棵树



https://ac.nowcoder.com/acm/contest/7609/C

给定树，一个点被感染后每秒钟向四周扩散一条边，每次操作一秒；三种操作：指定某点感染，集体免疫，询问某点是否被感染

对于询问$x$，检查是否存在$u$使得$dis(u,x)\leq t-t_u$，$t_u$为$u$发生感染的时间；
$$
depth[u]+depth[x]-2\times depth[lca(u,v)]\leq t-t_u\\
depth[u]+t_u-2\times depth[lca(u,v)]\leq t-depth[x]
$$
由于是一个点对一点集的关于lca的询问，运用小trick，每次感染的时候更新$u$到根每一个点$y$的$depth[u]+t_u-2\times depth[y]$最小值，最后询问$x$直接向上查找到根即可；维护不等式左侧需要树剖线段树维护区间$depth[u]+t_u$最小值，$depth[y]$最大值，$depth[u]+t_u-2\times depth[y]$最小值