https://ac.nowcoder.com/acm/contest/7615/D

给定一个排列，求有多少个上升序列$\{a_{p1},a_{p2}...a_{pm}\}$，$s.t.\nexists j<p_1\&a_j<a_{p1}$ 且 $\nexists p_i<j<p_{i+1}\& a_{pi}<a_j<a_{pi+1}$ 且 $\nexists p_m<j\& a_{pm}<a_j$

部分分做法是令$dp[i]$表示以$a_i$为结尾的满足前两个条件的上升序列个数，令$limit[j]$表示$j$到$i$之间$>a_j$的最小的数，则$dp[i]=[a_i==min_{j=1}^i\{a_j\}]+\sum\limits_j^{j<i~\&~a_j<a_i~\&~a_i<limit[j]}dp[j]$，要想满足最后一个条件，只需要倒着扫一遍看$a_i$是不是后缀最大值，复杂度$O(n^2)$

Q:请给出有效转移次数最多的构造

~~于是我们可以hack一大票包括最优解在内的代码了呢~~

考虑每个数作为结尾时，只关注比它小的数，所以我们从小到大加入这些数，重新定义$dp[i]$表示以数字$i$为结尾的满足前两个条件的上升序列个数，$pos[i]$表示数字$i$所在位置；如果$j<i$且$a_j>amax[j+1,i-1]$，那么$dp[j]$就对$dp[i]$有贡献；问题转化为快速算出一个区间的$a_i,a_{i+1},a_{i+2}...$跨过其右边相邻某一定值$limit$的贡献和

你很灵性的发现这个东西是可以分治的，如果将区间分成左右两个子区间，左区间要跨过右区间最大值贡献，右区间要跨过$limit$贡献，于是建线段树维护这玩意，记录$lans[rt]$表示以$rt$为根的左子树跨过右子树的最大值能贡献的值

具体来讲，如果右子树最大值$<limit$，即无论如何也不可能贡献，则递归处理左子树；否则左子树要且只要跨过右子树最大值就能贡献更右边的，即左子树的贡献就是$lans[rt]$，递归处理右子树的贡献；线段树查询区间$[1,pos[i]]$时先做右区间再做左区间可以维护当前区间要跨过的$limit$值

单次询问区间跨过定值的贡献和复杂度为$O(logn)$，而求$[1,pos[i]]$区间会拆成$logn$个区间，所以计算单个$f[i]$的复杂度是$O(log^2n)$的；$lans[rt]$的维护也是一个区间跨过定值的子问题，单个更新复杂度$O(logn)$，单次更新$pos[i]$位置$f[i]$的值会有$logn$个区间的$lans$被更改，所以单次更新的复杂度是$O(log^2)$的；总时间复杂度$O(nlog^2 n)$



http://zhengruioi.com/contest/759/problem/1685

给定一$01$串，每次选择一个子序列(不连续)包含$a$个$0$和$b$个$1$，且第一个和最后一个被选择的数之间没有前几次被选择过的数，给出一种选择方案，使得每个数都被选过

前缀+后缀不一定能凑成$a$个$0$和$b$个$1$，因为有可能从中间抽走一个

既然无法从外向里剥皮，那就从里面掏空它；每次删除一段满足条件的子串，后面顺位补齐；这个过程可以用栈模拟，顺次加入栈，长度为$a+b$的区间中$0$的个数是连续变化的，所以一定可以找到满足条件的子串，删除后就是另一个子问题也一定可以找到



http://zhengruioi.com/problem/1686

对于$n$个点的无向图，将floyd求连通性最外层循环从$[1,n]$变成$[1,n-m]$，求有多少个图的$n^2$个连通关系都不变

即将$[n-m+1,n]$设为禁点，不参与转移，剩下的$[1,n-m]$为自由点，随意转移

考虑满足条件的图一定满足：如果一个连通块全部由禁点构成，那么一定是个完全图；如果联通块全部由自由点构成，那么只要联通即可，这样的连通块方案数$g[i]$可以预处理出来；如果禁点和自由点混合，禁点之间是完全图，自由点之间联通，且每个禁点都与至少一个自由点相连

设$dp[i][j]$表示一共有$i$个点，其中$j$个点是禁点的方案数，$g[i]$表示$i$个点组成一个联通块的方案数，$g[i]=2^{\frac{i\times(i-1)}{2}}-\sum\limits_{j=1}^{i-1}\binom{i-1}{j-1}\times g[j]\times 2^{\frac{(i-j)\times (i-j-1)}{2}}$即用总数$-$最后一个连通块大小$\neq i$的情况；枚举最后一个连通块中禁点和自由点的数量：如果没有自由点，方案数$+=$其余点的方案数$\times$在所有禁点/自由点中选择的方案数$\times $每个禁点向至少一个自由点连边的方案数$\times$所有禁点连成完全图的方案数，即$dp[i][j]+=\sum\limits_{u=1}^{j}\sum\limits_{v=1}^{i-j}dp[i-u-v][j-u]\times \binom{j-1}{u-1}\times \binom{i-j}{v}\times (2^v-1)^u\times g[v]$；如果有自由点，则对禁点间的连边不做限制，因为无论如何连都可以通过自由点连通$dp[i][j]+=\sum\limits_{u=1}^{j}\sum\limits_{v=1}^{i-j}dp[i-u-v][j-u]\times \binom{j-1}{u-1}\times \binom{i-j}{v}\times (2^v-1)^u\times g[v]\times 2^{\frac{u\times(u-1)}{2}}$



https://ac.nowcoder.com/acm/contest/7613/C

给定一排列，多次询问$[l,r]$区间内字典序第$k$小的数

区间静态第$k$小模板，套个马甲就不认识了？先预处理出$1-n$每个数在字典序下排第几，这个转成字符串sort一下即可，然后将原来的值替换掉，直接上主席树做区间静态第$k$小，输出再把值转回来；本题数据较水，分块也能过，时间十倍



http://zhengruioi.com/contest/754/problem/1674

给定一字符串，求有多少长度为$6$的子序列满足相等/不相等关系形如$114514$

枚举$5$的位置，我们需要知道前缀$114$的数量和后缀$14$的数量，通过dp

$dp0[i][x]$表示$[1,i]$中$x$的个数，$dp0[i][x]=dp0[i-1][x]+[a[i]==x]$

$dp1[i][x]$表示$[1,i]$中$xx$的个数，$dp1[i][x]=dp1[i-1][x]+[a[i]==x]\times dp0[i-1][x]$

$dp2[i][x][y]$表示$[1,i]$中$xxy$的个数，$dp2[i][x][y]=dp2[i-1][x][y]+[a[i]==y]\times dp1[i-1][x]$

$dp3[i][x][y]$表示$[i,n]$中$xy$的个数，$dp3[i][x][y]=dp3[i+1][x][y]+[a[i]==x]\times(dp0[n][y]-dp0[i][y])$

卡了空间，不能开这么多数组，先把$i==1$时$dp3[x][y]$算出来，这样向后推的时候四个式子都能动态维护省掉第一维



http://zhengruioi.com/contest/754/problem/1675

给定一个只含有$!,\&,|$符号的布尔表达式，其中含有$n$个未知数，给定$2^n$种情况下每个未知数的取值，检查表达式的值是否正确

因为没有括号，可以看做是一堆连$\&$(夹杂了一些$!$) 或起来的式子，每一段连与为真解是一定的，而最终只需要完全满足某一块的解即可；于是把$a[i]$的状态压缩进bool数组$0$表示无关，$1$表示必须为false，$2$表示必须为true，读入完一块后可以算出该快涉及到的变量的取值，其他都是无关变量，最后顺着转移一遍即可得到所有可能的解；将需要验证的情况也转成三进制看是否是可能解



http://zhengruioi.com/contest/759/problem/1687

给定一直方图，每个位置有一高度，求被围起来的部分可以画出的第$ql$到第$qr$小矩形的面积

预处理$[l[i],r[i]]$表示可以以$i$为最低点(若高度相同则序号最小)构成矩阵的区间，这样每个矩形都会不重不漏地被统计到；于是可以$O(n)$算出面积$\leq S$的矩阵个数，每个点的贡献为$Cal(\frac{S}{a[i]})-Cal(\frac{S}{a[i]}-l)-Cal(\frac{S}{a[i]}-r)+Cal(\frac{S}{a[i]}-l-r)$其中$Cal(x)=\sum\limits_{i-1}^xi=\frac{i\times (i-1)}{2}$，这样二分出$ql$所在段的面积大小$start$，我们还需要这样向后推到$qr$

后面就是经典问题，由于每个点的矩阵长度取值是连续的，所以把面积$\geq start$最短可能长度放入小根堆(以面积为关键字)，每次取出头部，再加入长度+1的头部，仿照上面容斥也可以$O(1)$算出每个点某一长度下的矩形数量



https://ac.nowcoder.com/acm/contest/7613/D

在二维坐标中给出若干不相交不相切的圆，求从$x$圆弧上任意点到$y$圆弧上任意点至少需要穿过几个圆

可以想到最终一定是从两端分别走，直到被一个更大的圆同时包含；如果一个圆弧套在$x$外面，只要它没有超过更大的圆则一定要穿，否则一定不穿；实际上抽象一下就是在树上跳LCA的过程，于是建树，儿子关系是被套关系，这样答案就是LCA的距离$-1/-2$了；问题转化为快速求圆之间的包含关系(直接)，由于圆之间是不相交的，也就是说在下一个圆进入/离开之前包含关系不变，所以维护每个圆的上弧和下弧所在的$y$坐标，如果当前插入的圆向上的第一个圆是上弧，则是被包含的关系，否则是兄弟关系，这样就可以建出整棵树



https://ac.nowcoder.com/acm/contest/7609/C

给定树，一个点被感染后每秒钟向四周扩散一条边，每次操作一秒；三种操作：指定某点感染，集体免疫，询问某点是否被感染

对于询问$x$，检查是否存在$u$使得$dis(u,x)\leq t-t_u$，$t_u$为$u$发生感染的时间；
$$
depth[u]+depth[x]-2\times depth[lca(u,v)]\leq t-t_u\\
depth[u]+t_u-2\times depth[lca(u,v)]\leq t-depth[x]
$$
由于是一个点对一点集的关于lca的询问，运用小trick，每次感染的时候更新$u$到根每一个点$y$的$depth[u]+t_u-2\times depth[y]$最小值，最后询问$x$直接向上查找到根即可；维护不等式左侧需要树剖线段树维护区间$depth[u]+t_u$最小值，$depth[y]$最大值，$depth[u]+t_u-2\times depth[y]$最小值



http://zhengruioi.com/contest/717/problem/1598

给定一$a[1,n]$排列，求$p[1,n-1]$的操作排列数量，每个操作表示交换原排列中的$a_{p_i},a_{p_{i+1}}$，使得操作后原排列升序

观察到如果$a[i]==i$一定无解，如果$a[i]<i$说明要一路移动到更左边，所以这一路上的点一定是先做(相对它左边相邻的点)，两端点后做；否则一路上的点一定是后做的，两端点先做；这样就转化为了求排列数量满足$b_{i-1}<b_i$或$b_{i-1}>b_i$，$dp[i][j]$表示考虑了前$i$个数，最后一个数排名(从小到大)为$j$时的方案数，当要求$b_{i-1}<b_i$时$dp[i][j]=\sum\limits_{k=1}^{j-1}dp[i-1][k]$，要求$b_{i-1}>b_i$时$dp[i][j]=\sum\limits_{k=j}^{i-1}dp[i-1][k]$



http://zhengruioi.com/contest/730/problem/1641

给定二维坐标系中的若干个点，定义直接两点的直接距离为$||x1-x2|-|y1-y2||$，两点的距离可以通过走过若干直接距离的和构成，求距离$\neq 0$的两点的最小距离以及方案数

发现这个式子和曼哈顿距离$dx+dy$只差了一个符号，而对待曼哈顿距离我们一般会旋转坐标系$x->x+y~;~y->x-y$变成切比雪夫距离$max(dx,dy)$求解，所以这道题同理，旋转过后的两点距离变成$min(dx,dy)$，将所有$x$或$y$相同的点先缩起来，之后最短距离一定是直接距离，将所有点按$x$排序看相邻的距离，再按$y$排序看相邻距离，这样一定可以找到最短距离；具体来讲对坐标建并查集，每遇到一个点就把他的$x$和$y$合并起来，这意味着所有$x$和该点相同的点与所有$y$和该点相同的点距离变成0



http://zhengruioi.com/contest/763/problem/595

给定一$n$个点的树，定义两点间距离为经过路径长度的乘积，定义排列的价值为所有相邻点之间的距离之和，求所有长度为$n$的排列的价值和

考虑每个点作为排列中的前一位，与其他点作为排列中相邻后一位的贡献和；这样总共有$(n-2)!\times (n-1)=(n-1)!$种排列，而求每个点与其他所有点的距离之和直接用树形dp，$dp[0][i]$表示以$i$为根的子树中所有点到$i$的距离和$=\sum\limits_{to[j]\in son[i]}value[j]+dp[0][to[j]]\times value[j]$，$dp[1][i]$表示以$i$为根的子树外所有点到$i$的距离和$dp[1][to[j]]=dp[1][i]\times value[j]+(dp[0][i]-dp[0][to[j]]\times value[j]-value[j])\times value[j]$



https://darkbzoj.tk/problem/3110

维护$n$个可重集，有两个操作：在编号$\in [a,b]$的每一个集合中加入一个数$c$，或询问编号$\in [a,b]$所有集合包含的所有数中第$c$大的数

考虑整体二分答案，对位置建线段树记录区间集合包含的数的数量，顺着扫属于本区间的操作：如果是修改操作，如果修改的值$>mid$，就在线段树上修改，并放入右子区间，否则放入左子区间；如果是询问操作，对区间求和，如果不足$c$，以为这需要更小的数凑数，则答案位于左子区间，将要求减去当前期间的贡献放入左子区间，否则放入右子区间递归处理



https://www.luogu.com.cn/problem/P4279

给定$n$堆石子，两人轮流拿，每次可以任选一堆从中拿任意多石子，拿到所有堆最后一个石子的人输，求先手必胜/必败

$anti-nim$游戏

情况一：所有堆石子个数全为1，则偶数堆必胜，奇数堆必输

情况二：只有一堆石子个数$>1$，则先手必胜，因为他一个可以把必输的情况1给对手

有$\geq $两堆石子个数$>1$，仿照$nim$游戏讨论异或和的情况

情况三：异或和$=0$时，要么把情况二给对手，必输，要么只能把情况三给对手

情况四：异或和$!=0$时，在$nim$游戏中已证这样一定可以把情况三给对手

所以情况三必输，情况四必胜



http://zhengruioi.com/contest/730/problem/1642

给定一个初始的01串，一次操作把原来所有相邻的前0后1进行交换构成新串，求$t$次操作后的字符串串，以及每一次操作后的逆序对数量

对每一个字符1求其在第$i$次操作中能否向前交换，能1不能0：如果当前字符的前一位也是1，那么状态就会比前一位整体慢一步，并且第一步也是0；否则如果和上一个1之间隔了$k$个0，可以先认为两个1是相邻的计算移动状态，每次当前的1被卡位了就无中生有一个0让它能继续移动，所以就将状态前$k$个0变成1；维护状态可以通过deque维护0的位置并打全局$tag$；第$i$位字符1的移动状态中有$j$个0就意味着阻止了$t$次移动中的$j$次，所以这一位的1最终的位置在$i-t+j$；每一个1每移动一次就会增加一个逆序对个数，所以操作一次的逆序对变化量就是当前操作时间上所有字符1的移动数量，而某一位字符的移动状态中的一个0变成1，会使其之后的所有字符1的移动状态上慢1,2,3...位也从0变成1；所以记录当前操作位是否变化是移动数量的差分值，求和之后就是逆序对的变化量了