https://ac.nowcoder.com/acm/contest/7615/D

给定一个排列，求有多少个上升序列$\{a_{p1},a_{p2}...a_{pm}\}$，$s.t.\nexists j<p_1\&a_j<a_{p1}$ 且 $\nexists p_i<j<p_{i+1}\& a_{pi}<a_j<a_{pi+1}$ 且 $\nexists p_m<j\& a_{pm}<a_j$

部分分做法是令$dp[i]$表示以$a_i$为结尾的满足前两个条件的上升序列个数，令$amax[j]$表示$j$到$i$之间$>a_j$的最小的数，则$dp[i]=[a_i==min_{j=1}^i\{a_j\}]+\sum\limits_j^{j<i~\&~a_j<a_i~\&~a_i<limit[j]}dp[j]$，要想满足最后一个条件，只需要倒着扫一遍看$a_i$是不是后缀最大值，复杂度$O(n^2)$

考虑每个数作为结尾时，只关注比它小的数，所以我们从小到大加入这些数，重新定义$dp[i]$表示以数字$i$为结尾的满足前两个条件的上升序列个数，$pos[i]$表示数字$i$所在位置；如果$j<i$且$a_j>amax[j+1,i-1]$，那么$dp[j]$就对$dp[i]$有贡献；问题转化为快速算出一个区间的$a_i,a_{i+1},a_{i+2}...$跨过其右边某一定值$limit$的贡献和

建线段树，记录$lans[rt]$表示以$rt$为根的左子树跨过右子树的最大值能贡献的值

如果右子树最大值$<limit$，即无论如何也不可能贡献，则递归处理左子树；否则左子树一定要跨过右子树最大值才能贡献更右边的，即左子树的贡献就是$lans[rt]$，递归处理右子树的贡献；线段树查询区间$[1,pos[i]]$时先做右区间再做左区间可以维护当前区间要跨过的$limit$值

单次询问区间跨过定值的贡献和复杂度为$O(logn)$，而求$[1,pos[i]]$区间会拆成$logn$个区间，所以计算单个$f[i]$的复杂度是$O(log^2n)$的；$lans[rt]$的维护也是一个区间跨过定值的子问题，单个复杂度$O(logn)$，单次更新$pos[i]$位置$f[i]$的值会有$logn$个区间的$lans$被更改，所以单次更新的复杂度是$O(log^2)$的；总时间复杂度$O(nlog^2 n)$