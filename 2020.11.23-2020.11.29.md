https://codeforces.com/contest/734/problem/E

给定一棵树，每个节点初始黑色或白色，每次可以将一个相同颜色连通块内的点颜色翻转，求最小操作次数使得整棵树变成一种颜色

既然每次都对一个连通块操作，那我们就把颜色相同连通块先缩点，缩完点后的树是黑白相间的，则最小操作次数就是从直径的中心出发做$\frac{len}{2}$次



http://zhengruioi.com/contest/736/problem/1657

$n$个物品，每个物品物品有重量和价值，$m$个背包，一个背包只能放一个物品，选出一些物品使得他们的重量和价值都是单调不降的，并且都能放到背包中，求最多能选出多少物品

要想都放进去，肯定放入后若干背包，所以二者均按重量排序；要想价值单调不降，设$dp[i]$表示最后一次选的物品的价值为$i$时的最大物品数量，由于我们不清楚第一个物品放哪个背包，但重量最大的物品一定放最后一个背包，所以要倒着做，考虑如果当前位$u$可以由后方物品$v$转移而来，即$dp[value[u]]=max(dp[value[u]],dp[value[v]]+1)$，有$value[u]\leq value[v]$，所以把$dp[value[u]]$放到$value[u]$处，每次查询后缀最大值转移，并检查是否能放进去



http://zhengruioi.com/contest/736/problem/1658



一个重要的转化是我们无需在两只蚂蚁相遇的第一个点让某个人等候，因为如果他们中一定有人要等，那么他们到达根的时间一定是紧挨着的，也就是说我们只需要在根节点处处理同一深度下节点的到达情况，



http://zhengruioi.com/problem/1571

对于$n$个点，给定若干形如$x$必须出现在$y$前面的限制条件，求一出现顺序，依次满足$1,2...n$出现的位置尽可能早

看起来是拓扑排序，对于$i$点的出现，一定要等它前面所有点出现完才能出现，然而对于正图我们不好处理前面的次大点使其尽早出现，所以建反图倒着跑拓扑排序，每次选节点编号最大的使其出现在末尾；对于类似的限制不能求正序字典序是由于可能为了眼前小利丢了重点，可以转化成倒序最大字典序是因为越小的点越会不断被向前挤压，满足条件



http://zhengruioi.com/contest/723/problem/1573

给定数列$a,b,c$和数字$P$，当解$\sum\limits_{i=1}^na[i]\times x[i]\leq P$且$\sum\limits_{i=1}^na[i]\times x[i]\geq P$时，最小化$\sum\limits_{i=1}^n c[i]\times x[i]$，其中$x[i]\in\{0,1\}$

由于所有的$a_i\leq b_i$，所以如果有一种方案满足$sum(a)\leq P\leq sum(b)$，那么对于每一个$x_i=1$的位置，一定可以找到一个$a_i\leq u_i\leq b_i$使得$sum(u)=P$，所以设$dp[i][j]$表示考虑到第$i$位，$sum(u)=j$时$sum(c)$的最小值，$dp[i][j]=min(dp[i-1][j],dp[i-1][j-u]+1),u\in[a[i],b[i]]$，遍历$i,j$转移，$j$单调时拿单调队列维护后一个的最小值



http://zhengruioi.com/contest/723/problem/1571

对于两组数$a[1,n],b[1,m]$，求有多少对$i\in[1,n],j\in[1,m]$使得$a[i]$异或$b[j]$在二进制下恰有两位是1

异或起来有两位为1意味着两个数只有两位不相等

$70pts:$对于$a$中的每个数枚举可能是哪两位和它不一样，这样就得到了所有可能和它贡献的$b$的值，放map里，对$b[i]$求和$map[b[i]]$即可

$90pts:$没必要对一个数枚举两位，$a$变一位$b$变一位，且这两位不能相同；如果这两位相同了还被计算上了，那么一定有$a[i]=b[j]$，而且这一对会被算30遍，减去即可，这之后每一对会被算两遍(a改x，b改y；a改y，b改x)，/2即可

$100pts:$手写哈希表当map用



http://zhengruioi.com/contest/770/problem/127

定义排列的价值为$\sum\limits_{i=1}^n[a[i]==min\{a[1-i]\}]$，求所有$[1,n]$的排列价值平方和

考虑每次在已有排列中加入一个最大的数，$dp[i][j]$表示用$i$个数凑出价值为$j$的排列方案数：

$dp[i][j]=dp[i-1][j-1]+(i-1)\times dp[i-1][j]$，然而没有必要维护出整个dp数组
$$
ans[i]=\sum\limits_{j=1}^ij^2\times dp[i][j]\\=
\sum\limits_{j=1}^i ((j-1)^2+2j+1)\times (dp[i-1][j-1]+(i-1)dp[i-1][j])\\
=ans[i-1]+2b[i-1]+c[i-1]+(i-1)ans[i-1]\\
=i\times ans[i-1]+2b[i-1]+c[i-1]\\
\\
\\
b[i]=\sum\limits_{j=1}^i j\times dp[i][j]\\
=\sum\limits_{j=1}^i (j-1+1)\times (dp[i-1][j-1]+(i-1)\times dp[i-1][j])\\
=b[i-1]+\sum\limits_{j=1}^jdp[i-1][j-1]+(i-1)\times b[i-1]\\
=i\times b[i-1]+c[i-1]\\
\\
\\
c[i]=\sum\limits_{j=1}^idp[i][j]\\
=\sum\limits_{j=1}^i(dp[i-1][j-1]+(i-1)dp[i-1][j])\\
=c[i-1]+(i-1)\times c[i-1]\\
=i\times c[i-1]
$$